[{"content":"插头 molex\njst\n图例 JST ZH 4 pin\nJP[x]：jumper 跳线接口 ECU 倒也不一定是搞汽车要用，只能说为无引脚，但焊点在四周的芯片的免拆做出贡献\n支架\nLED BDM Frame 探针\nQiilu Probe Pens（BDM Frame 中自带的，及其不好组装 =.=）\nKIMISS Probe Pens\n","date":"2023-02-27T11:28:00Z","permalink":"https://binlep.github.io/p/iot-%E8%AE%BE%E5%A4%87%E8%AE%B0%E5%BD%95/","title":"IOT 设备记录"},{"content":"宏定义相关 可以由传进来的变量生成任意变量类型的变量\n1 #define typeof(expr) __res = (expr); 函数相关 getopt 问题情景：打算调用两次 getopt 函数，兼容 DEBUG 测试\n思路：第二次运行之前，将 optind 的值重新赋值为 1\n在 x86 架构下运行正常，但是在 arm 下没有通过输入数据的判断函数\n经 GDB 调试发现，在 arm 下运行完 getopt 函数后，其第二个参数内的指针地址会乱序\n解决方案：不要用 argv 当 getopt 的参数，建立一个指针缓存变量，不断拷贝原本 argv 内的地址即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;alloca.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(int argc, char *argv[], char *envp[]) { int ret, i; extern char *optarg; extern int optind; char **targv = alloca(sizeof(char *) * argc); for (i = 0; i \u0026lt; argc; ++i) { targv[i] = argv[i]; } while ((ret = getopt(argc, targv, \u0026#34;:v:\u0026#34;)) != -1) { // ... } optind = 1; for (i = 0; i \u0026lt; argc; ++i) { targv[i] = argv[i]; } while ((ret = getopt(argc, targv, \u0026#34;:A:B:\u0026#34;)) != -1) { // ... } } ","date":"2022-11-15T09:40:00Z","permalink":"https://binlep.github.io/p/c-%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","title":"C 语言开发笔记"},{"content":"无脑的解决方案 经测试，Python 3.9 是最合适的一个版本了，直接静态编译一个 Python，搞定 TLS 的难题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 mkdir -p /local/root/opt/{lib,source} export LIBDIR=/local/root/opt/lib export WORKDIR=/local/root/opt/source cd $WORKDIR \u0026amp;\u0026amp; \\ wget --no-check-certificate https://www.openssl.org/source/openssl-1.1.0l.tar.gz \u0026amp;\u0026amp; \\ tar -xzvf openssl-1.1.0l.tar.gz \u0026amp;\u0026amp; \\ cd openssl-1.1.0l \u0026amp;\u0026amp; \\ ./config shared \\ --openssldir=$LIBDIR/openssl \\ --prefix=$LIBDIR/openssl \\ -DOPENSSL_TLS_SECURITY_LEVEL=0 \u0026amp;\u0026amp; \\ make -j16 \u0026amp;\u0026amp; \\ make install # complie python 3.9.0 cd $WORKDIR \u0026amp;\u0026amp; \\ wget --no-check-certificate http://npm.taobao.org/mirrors/python/3.9.0/Python-3.9.0.tar.xz \u0026amp;\u0026amp; \\ tar -Jxvf Python-3.9.0.tar.xz \u0026amp;\u0026amp; \\ cd Python-3.9.0 \u0026amp;\u0026amp; \\ sed -i \u0026#34;s|OPENSSL_LIBS=\\\u0026#34;-lssl -lcrypto\\\u0026#34;|OPENSSL_LIBS=\\\u0026#34;\\$ssldir/lib/libssl.a \\$ssldir/lib/libcrypto.a\\\u0026#34;|g\u0026#34; ./configure \u0026amp;\u0026amp; \\ sed -i \u0026#34;s|libraries=openssl_libs|extra_objects=openssl_libs|g\u0026#34; ./setup.py \u0026amp;\u0026amp; \\ sed -i \u0026#34;s|split_var(\u0026#39;OPENSSL_LIBS\u0026#39;, \u0026#39;-l\u0026#39;)|split_var(\u0026#39;OPENSSL_LIBS\u0026#39;, \u0026#39;\u0026#39;)|g\u0026#34; ./setup.py \u0026amp;\u0026amp; \\ ./configure --prefix=$(pyenv root)/versions/openssl \\ --with-openssl=$LIBDIR/openssl \u0026amp;\u0026amp; \\ make -j16 \u0026amp;\u0026amp; \\ make install 繁琐的解决方案 UNSAFE_LEGACY_RENEGOTIATION_DISABLED 新建一个 openssl.cnf 文件，内容如下\n1 2 3 4 5 6 7 8 9 10 openssl_conf = openssl_init [openssl_init] ssl_conf = ssl_sect [ssl_sect] system_default = system_default_sect [system_default_sect] Options = UnsafeLegacyRenegotiation 之后更换 OPENSSL_CONF 环境变量运行 Python 脚本\n1 OPENSSL_CONF=openssl.cnf python3 demo.py CERTIFICATE_VERIFY_FAILED 将 Python 脚本中所有的 requests 库的请求函数加上 verify=False 参数\n1 print(requests.get(url=url, verify=False).content) UNSUPPORTED_PROTOCOL 本机的 openssl 编译时未曾添加所需 TLS 支持 若是碰到低版本的 TLS 建议用 Ubuntu 16.04 这些老版本的系统进行命令操作\n不然很可能得自己编译一个低版本的 openssl 来添加系统对低版本 TLS 的支持\n首先要查看本地的 openssl 库对该网站的协议是否支持，命令及结果如下所示\n1 2 3 4 5 # openssl s_client -help 2\u0026gt;\u0026amp;1 | awk \u0026#39;/-ssl[0-9]|-tls[0-9]/{print $1}\u0026#39; -tls1 -tls1_1 -tls1_2 -tls1_3 接着要查看本地的 openssl 是否支持对应的加密方式\n1 2 3 4 5 # openssl ciphers -s -v TLS_AES_256_GCM_SHA384 TLSv1.3 Kx=any Au=any Enc=AESGCM(256) Mac=AEAD TLS_CHACHA20_POLY1305_SHA256 TLSv1.3 Kx=any Au=any Enc=CHACHA20/POLY1305(256) Mac=AEAD TLS_AES_128_GCM_SHA256 TLSv1.3 Kx=any Au=any Enc=AESGCM(128) Mac=AEAD ... 但是如上两行命令也可能不能帮你获晓 openssl 对所需 TLS 提供支持的具体情况\n可以选择用浏览器查看网站，再点击证书，或用 curl 命令来访问网址\n这两种方式是都可以看到网站所用 TLS 版本信息及加密方式的\n本机的 openssl 支持该 TLS 版本 可用 curl 先证明一下能否支持，如下是能够支持 TLS 的样例\n1 2 3 4 5 6 7 8 # curl --insecure -vi https://example.com * Rebuilt URL to: https://example.com/ * Trying xxx.xxx.xxx.xxx... * Connected to example.com (xxx.xxx.xxx.xxx) port 443 (#0) * found 129 certificates in /etc/ssl/certs/ca-certificates.crt * found 516 certificates in /etc/ssl/certs * ALPN, offering http/1.1 * SSL connection using TLS1.0 / RSA_AES_256_CBC_SHA1 如下是不能支持该 TLS 的样例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # curl --insecure -vi https://example.com * Rebuilt URL to: https://example.com/ * Trying xxx.xxx.xxx.xxx... * Connected to example.com (xxx.xxx.xxx.xxx) port 443 (#0) * ALPN, offering h2 * ALPN, offering http/1.1 * TLSv1.0 (OUT), TLS header, Certificate Status (22): * TLSv1.3 (OUT), TLS handshake, Client hello (1): * TLSv1.0 (IN), TLS header, Certificate Status (22): * TLSv1.3 (IN), TLS handshake, Server hello (2): * TLSv1.2 (OUT), TLS header, Unknown (21): * TLSv1.3 (OUT), TLS alert, protocol version (582): * error:0A000102:SSL routines::unsupported protocol * Closing connection 0 curl: (35) error:0A000102:SSL routines::unsupported protocol 新建一个 openssl.cnf 文件，内容如下\n1 2 3 4 5 6 7 8 9 10 11 openssl_conf = openssl_init [openssl_init] ssl_conf = ssl_sect [ssl_sect] system_default = system_default_sect [system_default_sect] MinProtocol = TLSv1.0 CipherString = DEFAULT@SECLEVEL=1 之后更换 OPENSSL_CONF 环境变量运行 Python 脚本\n1 OPENSSL_CONF=openssl.cnf python3 demo.py ","date":"2022-11-02T00:00:00Z","permalink":"https://binlep.github.io/p/python-requests-%E5%BA%93%E8%AF%B7%E6%B1%82-https-%E7%9A%84%E9%97%AE%E9%A2%98/","title":"Python requests 库请求 HTTPS 的问题"},{"content":"前言 这里列举的是不同的压缩包以及相同的压缩包在不同版本下的解压方式\ntar 默认压缩命令 tar -cvf demo.tar ./demo 默认解压命令 1 tar -xvf demo.tar 特定版本加解压命令 版本列表如下\n1 2 3 4 5 6 gnu GNU tar 1.13.x 格式 oldgnu GNU 格式 as per tar \u0026lt;= 1.12 pax POSIX 1003.1-2001 (pax) 格式 posix 等同于 pax ustar POSIX 1003.1-1988 (ustar) 格式 v7 old V7 tar 格式 用法\n1 tar -xvf demo.tar -H posix tar.bz2 默认压缩命令 1 tar -jcvf demo.tar.bz2 ./demo 默认解压命令 1 tar -jxvf demo.tar.bz2 tar.gz 默认压缩命令 1 tar -zcvf demo.tar.gz ./demo 默认解压命令 1 tar -zxvf demo.tar.gz ","date":"2022-10-25T15:44:00Z","permalink":"https://binlep.github.io/p/%E5%8E%8B%E7%BC%A9%E5%8C%85%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/","title":"压缩包的那些事"},{"content":"Linaro 编译器 https://releases.linaro.org/components/toolchain/binaries/ 海思编译器 官方不开源，找论坛救命：http://bbs.ebaina.com/forum-97-1.html\n","date":"2022-10-25T15:44:00Z","permalink":"https://binlep.github.io/p/%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%B0%E5%BD%95/","title":"编译器记录"},{"content":"论坛 家电维修论坛 - www.jdwx.info iFix 爱修网 - www.ifix.net.cn 其他 猫猫无线 - www.wifizoo.net ","date":"2022-10-25T09:24:00Z","permalink":"https://binlep.github.io/p/%E7%A1%AC%E4%BB%B6%E7%BD%91%E5%9D%80%E6%94%B6%E5%BD%95/","title":"硬件网址收录"},{"content":"前言 首先就是电烙铁和热风枪，电烙铁部分已有文章来介绍\n如果可以的话，推荐买一个焊台来工作，如若要求便携那就各买各的\n编程器 CH341A RT809F（性价比最高） RT809H（笔者主要用这个了，直接挑选最好的） 烧录座 不同的芯片对应不同的烧录座，基本都是转接到 DIP8 板子上\n24、25、26、93 等系列芯片 SOP8-150mil 烧录座\nSOP8-208mil 烧录座\nSOP16-300mil 烧录座\nNAND 芯片 TSOP48 烧录座 脚测夹 也称 免拆测试夹，可以不用拆卸芯片对硬件进行测试\n就是如何夹得一手没有接触不良引脚的技术需要各位自己锻炼\n夹子上的针分弯针和直针，弯针的夹子会比直针的夹子贵\nSOP8 脚测夹\nSOP16 脚测夹\n","date":"2022-10-24T16:16:00Z","permalink":"https://binlep.github.io/p/%E8%8A%AF%E7%89%87%E4%BF%AE%E7%90%86%E5%B7%A5%E5%85%B7/","title":"芯片修理工具"},{"content":"一些常用烙铁 黄花 907（性价比高）\nT12（有烙铁架和温度显示仪）\nT65（本质和 T12 差不多，但是便携）\nJBC CD-2SHQE（好用但是贵）\n一些常用工具 焊锡丝（当然没这个焊个寂寞）\n助焊剂（常见的助焊剂主要是固态的松香，听说液态助焊剂会更好）\n烙铁头（跟拧螺丝差不多，螺丝刀也需要装配特定的螺丝刀头来处理不同的螺丝）\n洗板水\n烙铁头 以下所列为烙铁头在不同电烙铁下的名称\n电烙铁 大刀头 小刀头 尖头 马蹄头 特尖头 T65 KR K65 BC2 BC3 ILS T100 K Ku BC2 BC3 ILS ","date":"2022-10-24T15:21:00Z","permalink":"https://binlep.github.io/p/%E7%94%B5%E7%83%99%E9%93%81/","title":"电烙铁"},{"content":"Question 0x01 configure 编译错误，报错如下\n1 meson ERROR: Command \u0026#34;/usr/bin/make distclean\u0026#34; failed with status 2. 原因是 meson 是在 buildir 下编译 configure 的，会出现路径错误的问题\n所以我们要在 configure 文件中写入如下代码以进入正确的目录\n1 2 3 4 #! /bin/bash DIR=\u0026#34;$( cd \u0026#34;$( dirname \u0026#34;${BASH_SOURCE[0]}\u0026#34; )\u0026#34; \u0026amp;\u0026amp; pwd )\u0026#34; cd \u0026#34;${DIR}\u0026#34; ","date":"2022-09-30T12:35:11Z","permalink":"https://binlep.github.io/p/meson-%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","title":"meson 问题汇总"},{"content":"项目下载\n注意，pyinstaller 不能用最新版\n目前 staticx 库还不能处理最新版的 pyinstaller 中用到的动态链接库\n1 2 pip3 install pyinstaller==4.10 pip3 install staticx 先将项目打包成二进制程序，这个时候程序是动态链接的\n1 pyinstaller -F yourcode.py 接着用工具staticx将经过上一步生成在dist文件夹内的程序转为静态链接的程序\n1 staticx --loglevel DEBUG dist/yourcode ./yourcode ","date":"2022-09-29T11:11:11Z","permalink":"https://binlep.github.io/p/python-%E8%84%9A%E6%9C%AC%E5%88%B0%E9%9D%99%E6%80%81elf%E6%96%87%E4%BB%B6/","title":"Python 脚本到静态ELF文件"},{"content":" 1 ctf: version magic \u0026#39;2.6.36.4brcmarm SMP preempt mod_unload modversions ARMv7 \u0026#39; should be \u0026#39;2.6.39.4-armexploitlab-therealsaumil SMP mod_unload ARMv7 \u0026#39; 暴力解决 路径\n1 ./output/toolchain/linux-3.6.9/include/linux/vermagic.h 直接修改\n1 2 3 4 5 6 7 8 9 # diff ./output/toolchain/linux-3.6.9/include/linux/vermagic.h.bak ./output/toolchain/linux-3.6.9/include/linux/vermagic.h 28,32c28 \u0026lt; #define VERMAGIC_STRING \\ \u0026lt; UTS_RELEASE \u0026#34; \u0026#34; \\ \u0026lt; MODULE_VERMAGIC_SMP MODULE_VERMAGIC_PREEMPT \\ \u0026lt; MODULE_VERMAGIC_MODULE_UNLOAD MODULE_VERMAGIC_MODVERSIONS \\ \u0026lt; MODULE_ARCH_VERMAGIC --- \u0026gt; #define VERMAGIC_STRING \u0026#34;2.6.36.4brcmarm SMP preempt mod_unload modversions ARMv7 \u0026#34; ","date":"2022-09-19T14:55:36Z","permalink":"https://binlep.github.io/p/kernel-vermagic-patch/","title":"Kernel VERMAGIC Patch"},{"content":"因为这部分内容是启动参数的设置，所以我们可以用如下的方式来搜索源码信息\n譬如我像查找 mtdparts 的源码信息\n1 grep -rn \u0026#39;MODULE_PARM_DESC(parts\u0026#39; 其他的启动参数也可仿照如上方式来进行查询\nmtd_id 1 mtd_id:size1(name1),size2(name2) 一般这样使用\n1 2 3 mtdparts=mtd-id:\u0026lt;size1\u0026gt;@\u0026lt;offset1\u0026gt;(\u0026lt;name1\u0026gt;), \\ \u0026lt;size2\u0026gt;@\u0026lt;offset2\u0026gt;(\u0026lt;name2\u0026gt;); \\ mtd_id:size1(name1),size2(name2) mtdparts 我们自己编写的时候，可以在实机上运行 dmesg 来查看 mtd 分区在内核中的地址\n再以此编写仿真时所需要的 mydparts 参数\n需要注意的是，内核要打开几个必要的宏：\nConfig 1\nCONFIG_CMD_MTD\nCONFIG_CMD_MTDPARTS\nConfig 2\nCONFIG_MTD_CMDLINE_PARTS 格式 mtdparts 的格式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 * mtdparts=\u0026lt;mtddef\u0026gt;[;\u0026lt;mtddef] * \u0026lt;mtddef\u0026gt; := \u0026lt;mtd-id\u0026gt;:\u0026lt;partdef\u0026gt;[,\u0026lt;partdef\u0026gt;] * \u0026lt;partdef\u0026gt; := \u0026lt;size\u0026gt;[@\u0026lt;offset\u0026gt;][\u0026lt;name\u0026gt;][ro][lk][slc] * \u0026lt;mtd-id\u0026gt; := unique name used in mapping driver/device (mtd-\u0026gt;name) * \u0026lt;size\u0026gt; := standard linux memsize OR \u0026#34;-\u0026#34; to denote all remaining space * size is automatically truncated at end of device * if specified or truncated size is 0 the part is skipped * \u0026lt;offset\u0026gt; := standard linux memsize * if omitted the part will immediately follow the previous part * or 0 if the first part * \u0026lt;name\u0026gt; := \u0026#39;(\u0026#39; NAME \u0026#39;)\u0026#39; * NAME will appear in /proc/mtd * * \u0026lt;size\u0026gt; and \u0026lt;offset\u0026gt; can be specified such that the parts are out of order * in physical memory and may even overlap. * * The parts are assigned MTD numbers in the order they are specified in the * command line regardless of their order in physical memory. * * Examples: * * 1 NOR Flash, with 1 single writable partition: * edb7312-nor:- * * 1 NOR Flash with 2 partitions, 1 NAND with one * edb7312-nor:256k(ARMboot)ro,-(root);edb7312-nand:-(home) mtdparts 可以由一个或多个 mtddef 组成。每个mtddef定义如下：\n1 \u0026lt;mtddef\u0026gt; := \u0026lt;mtd-id\u0026gt;:\u0026lt;partdef\u0026gt;[,\u0026lt;partdef\u0026gt;] mtddef 可以由mtd-id 和一个或多个partdef组成，每个partdef定义如下：\n因此在使用的时候，需要按照下面的格式来设置：\n1 mtdparts=mtd-id:\u0026lt;size1\u0026gt;@\u0026lt;offset1\u0026gt;(\u0026lt;name1\u0026gt;),\u0026lt;size2\u0026gt;@\u0026lt;offset2\u0026gt;(\u0026lt;name2\u0026gt;) 这里需要注意的地方如下：\nmtd-id 必须跟当前平台 flash 的 mtd-id 一致，不然整个 mtdparts会失效\n在 bootarg 参数中，可以指定当前 falsh 的 mtd-id\n指定mtdids:nand0=gen_nand.1,前面的 nand0 则表示第一个flash\nsize 在设置的时候，可以为实际的 size (xxM,xxK,xx)，也可以为-，表示剩余的所有空间，相关信息可以查看drivers/mtd/cmdlinepart.c中注释找到相关描述\nmtdparts 里mtd_id的值为nandnand，那么 kernel 的平台代码中也必须有一个名为nandnand的分区表，平台代码中的那张分区表可以为空，因为 mtdparts 中已经有了，就不会解析平台代码中设置的分区表，但是分区表的名字还是要匹配的。kernel 中默认的分区表的名字是 Nand\n样例 arm CONFIG_ARCH_VERSATILE 1 mtdparts=armflash:0x80000@0(boot),0x180000@0x80000(nvram),0x3e00000@0x200000(linux),0x19d3ac@0x4000000(rootfs),0x3ec0000@0x4000000(brcmnand),0x140000@0x7ec0000(asus) CONFIG_ARCH_IPROC 1 mtdparts=nand_iproc.0:1024k(nboot),1024k(nenv),8192k(nsystem),1038336k(ndata) mips nor flash 1 mtdparts=physmap-flash.0:0x30000@0x0(Bootloader)0x10000@0x30000(nvram)0x10000@0x40000(Factory)0xeb0000@0x50000(linux)0xd847c0@0x17b840(rootfs)0x100000@0xf00000(jffs2)0x1000000@0x0(ALL) mtd 分区内核地址 1 2 3 4 5 6 7 8 9 10 11 12 Concatenating MTD devices: (0): \u0026#34;armflash-0\u0026#34; (1): \u0026#34;armflash-1\u0026#34; into device \u0026#34;armflash\u0026#34; 6 cmdlinepart partitions found on MTD device armflash Creating 6 MTD partitions on \u0026#34;armflash\u0026#34;: 0x000000000000-0x000000080000 : \u0026#34;boot\u0026#34; 0x000000080000-0x000000200000 : \u0026#34;nvram\u0026#34; 0x000000200000-0x000004000000 : \u0026#34;linux\u0026#34; 0x000004000000-0x00000419d3ac : \u0026#34;rootfs\u0026#34; 0x000004000000-0x000007ec0000 : \u0026#34;brcmnand\u0026#34; 0x000007ec0000-0x000008000000 : \u0026#34;asus\u0026#34; 解析脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #!/usr/bin/env python3 # -*- coding: utf-8 -*- import argparse import os parser = argparse.ArgumentParser() parser.add_argument(\u0026#39;file\u0026#39;, help=\u0026#39;boot info file\u0026#39;) args = parser.parse_args() if args.file: with open(args.file, \u0026#34;rb\u0026#34;) as fd: data = fd.read().strip() output = b\u0026#39;mtdparts=armflash:\u0026#39; data = data.split(b\u0026#39;\\n\u0026#39;) for i in range(0, len(data)): line = data[i][data[i].find(b\u0026#39;0x\u0026#39;):].split(b\u0026#39; : \u0026#39;) addr = line[0].split(b\u0026#39;-\u0026#39;) name = line[1].strip(b\u0026#39;\u0026#34;\u0026#39;) output += hex(int(addr[1], 16) - int(addr[0], 16)).encode() output += b\u0026#39;@\u0026#39; output += hex(int(addr[0], 16)).encode() output += b\u0026#39;(\u0026#39; + name + b\u0026#39;)\u0026#39; print(output) with open(os.path.dirname(args.file) + \u0026#34;/mtdparts\u0026#34;, \u0026#34;wb\u0026#34;) as fd: fd.write(output + b\u0026#39;\\n\u0026#39;) /proc/mtd 1 2 3 4 5 6 7 8 / # cat /proc/mtd dev: size erasesize name mtd0: 00080000 00010000 \u0026#34;boot\u0026#34; mtd1: 00180000 00010000 \u0026#34;nvram\u0026#34; mtd2: 03e00000 00010000 \u0026#34;linux\u0026#34; mtd3: 0019d3ac 00010000 \u0026#34;rootfs\u0026#34; mtd4: 03ec0000 00010000 \u0026#34;brcmnand\u0026#34; mtd5: 00140000 00010000 \u0026#34;asus\u0026#34; nandsim.parts 格式如下\n1 nandsim.parts=64,64,64,64,64,64,64,64,64,64 开启方式\n内核配置 CONFIG_MTD_NAND_NANDSIM 用户手动开启 1 2 3 4 5 6 modprobe nandsim first_id_byte=0xc8 \\ second_id_byte=0xd1 \\ third_id_byte=0x80 \\ fourth_id_byte=0x95 \\ cache_file=/root/nandsim.bin \\ \\ parts=8,8,8,20,20,256,256,224,220 开启后内核启动后会打印出模拟 NAND 芯片的名字，一般如下\n1 Manufacturer ID: 0x98, Chip ID: 0x39 (Toshiba NAND 128MiB 1,8V 8-bit) 但是模仿出来的 mtd 块名字不能更改，内部获取名字的函数如下\n1 2 3 4 static char __init *ns_get_partition_name(int i) { return kasprintf(GFP_KERNEL, \u0026#34;NAND simulator partition %d\u0026#34;, i); } 参考链接 https://blog.csdn.net/gangdou/article/details/113044235 https://cloud.tencent.com/developer/article/1012145 ","date":"2022-09-19T13:23:00Z","permalink":"https://binlep.github.io/p/u-boot-%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/","title":"U-Boot 启动参数"},{"content":"修改 .dynsym 上的符号 正常修改符号表拿 objcopy 就能解决，这里记录一下修改.dynsym段的符号方式\n有个已经写好的项目\nELFkickers/redefine at master · k1988/ELFkickers · GitHub 这项目里的 redefine 是作者新加的文件夹，程序使用起来也很简单\n1 ./redefine -r -i -n nvram_get_int -p nouse_get_int libnvram-armx.so 之后就能看到.dynsym中的符号已经修改完毕\n1 2 # arm-linux-gnueabi-objdump -T libnvram-armx.so | grep get_int 000032a4 g DF .text 0000005c nouse_get_int 参考链接 修改so导出函数名称 | k1988\nhttps://blog.csdn.net/gxd_506/article/details/38843567\n","date":"2022-09-17T10:45:00Z","permalink":"https://binlep.github.io/p/elf-%E7%A8%8B%E5%BA%8F%E9%AD%94%E6%94%B9%E6%89%8B%E6%AE%B5/","title":"ELF 程序魔改手段"},{"content":"准备工作 官网的安装教程很详细了，这里就不说了\n项目地址：GitHub - therealsaumil/emux 该项目的端口映射配置在run-emux-docker文件中，默认的端口映射如下\nhost emux 20080 80 20443 443 28080 8080 24433 4433 9999 9999 模拟新固件 准备文件 这部分官网教程说的也差不多了\n需要注意的是，一定得把固件根目录打包成tar.bz2格式的压缩包\n1 tar -vcjf squashfs-root.tar.bz2 ./squashfs-root/ 最后文件层次结构如下\n1 2 3 4 5 6 7 8 9 10 /emux/files/emux/RT-AC68U# tree . ├── config ├── kernel │ └── zImage-2.6.39.4-vexpress -\u0026gt; ../../template/kernel/zImage-2.6.39.4-vexpress ├── mtdparts ├── nvram.ini ├── preload │ └── libnvram-armx.so └── squashfs-root.tar.bz2 再重新构建并启动即可\n1 2 ./build-emux-volume ./run-emux-docker nvram 修复 有时候，调用 nvram 的函数构成也不一样，厂家多会自己 DIY 这部分内容\n这时我们就需要反汇编固件中管理 nvram API 的库\nemux 也有这部分的源码仓库地址，如下\nGitHub - therealsaumil/custom_nvram 构建 emux 程序的交叉编译工具包\nGitHub - therealsaumil/emux-buildroot-toolchains step 1：修复交叉编译工具\n首先把交叉编译工具包解压出来，因为该工具链不是本地编译的\n所以对于一些工具会有错误的动态链接，我们需要修改其中 cc1 工具的动态链接库\n路径如下\n1 /emux-buildroot-toolchains/arm-unknown-linux/usr/libexec/gcc/arm-unknown-linux-uclibcgnueabi/4.3.6 起初 cc1 和 cc1plus 工具的动态链接库均有损坏，这里就只对 cc1 作出改动\n1 2 3 4 5 6 # ldd ./cc1 linux-vdso.so.1 (0x00007fffc8af2000) libmpfr.so.4 =\u0026gt; not found libgmp.so.10 =\u0026gt; /lib/x86_64-linux-gnu/libgmp.so.10 (0x00007f65e1373000) libc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f65e1181000) /lib64/ld-linux-x86-64.so.2 (0x00007f65e1418000) 能看到该工具是找的本机的动态链接库，我们需要利用 patchelf 修改一下\n1 2 3 patchelf --set-rpath \\ /emux-buildroot-toolchains/arm-unknown-linux/usr/lib \\ ./cc1 之后就能正常使用了\n1 2 3 4 5 6 # ldd ./cc1 linux-vdso.so.1 (0x00007ffca8dd9000) libmpfr.so.4 =\u0026gt; /emux-buildroot-toolchains/arm-unknown-linux/usr/lib/libmpfr.so.4 (0x00007fa480ee7000) libgmp.so.10 =\u0026gt; /emux-buildroot-toolchains/arm-unknown-linux/usr/lib/libgmp.so.10 (0x00007fa480c79000) libc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa480a68000) /lib64/ld-linux-x86-64.so.2 (0x00007fa481145000) step2：编译自定义的 nvram 库文件\n从 custom_nvram 项目中选一个 C 文件作为模板，本文用的是custom_nvram_r6250.c\n该文件中虽然也写了如何对其进行编译，但是没有对 undefined 的符号做出约束\n可能会导致使用的人无法注意到没有链接到 dl 库，所以我们这里做一下补充\n在其中加上对libdl.so的链接即可\n1 2 3 4 5 /emux-buildroot-toolchains/arm-unknown-linux/usr/bin/arm-linux-gcc \\ -shared \\ -fPIC \\ -ldl \\ -o libnvram.so custom_nvram_r6250.c ","date":"2022-09-16T17:58:30Z","permalink":"https://binlep.github.io/p/emux-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/","title":"emux 使用笔记"},{"content":"预备工作 cross.ini 样例 以下用的mingw64编辑器版本为x86_64-12.2.0-release-posix-seh-rt_v10-rev0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [constants] cross_root = \u0026#39;E:/cross-tools/mingw64/bin/\u0026#39; qt_root = \u0026#39;E:/Qt/5.15.6/qtbase/\u0026#39; target = \u0026#39;\u0026#39; [binaries] c = cross_root + target + \u0026#39;gcc\u0026#39; cpp = cross_root + target + \u0026#39;g++\u0026#39; ar = cross_root + target + \u0026#39;ar\u0026#39; strip = \u0026#39;strip\u0026#39; qmake = qt_root + \u0026#39;/bin/qmake\u0026#39; [host_machine] system = \u0026#39;windows\u0026#39; cpu_family = \u0026#39;x86\u0026#39; cpu = \u0026#39;i386\u0026#39; endian = \u0026#39;little\u0026#39; [properties] qt_root = qt_root meson.build 编译 动态编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 project(\u0026#39;qtdemo\u0026#39;, \u0026#39;cpp\u0026#39;, version : \u0026#39;0.1\u0026#39;, default_options : [\u0026#39;warning_level=3\u0026#39;, \u0026#39;cpp_std=c++17\u0026#39;]) qt5_mod = import(\u0026#39;qt5\u0026#39;) qt5_dep = dependency(\u0026#39;qt5\u0026#39;, modules: [\u0026#39;Core\u0026#39;, \u0026#39;Widgets\u0026#39;]) qt5_path = \u0026#39;library/qt/\u0026#39; # qt library subdir(qt5_path) processed = qt5_mod.preprocess( moc_headers : qt5_path + \u0026#39;include/mainWindow.h\u0026#39;, # Only headers that need moc should be put here moc_sources : qt5_path + \u0026#39;source/mainWindow.cpp\u0026#39;, # must have #include\u0026#34;moc_helperFile.cpp\u0026#34; ui_files : qt5_path + \u0026#39;mainWindow.ui\u0026#39;, ) INCLUDE_HDR = [] INCLUDE_HDR += include_directories(\u0026#39;include\u0026#39;) INCLUDE_HDR += QT_HDR MHF_SRC = [] MHF_SRC += \u0026#39;main.cpp\u0026#39; MHF_SRC += processed MHF_SRC += QT_SRC if build_machine.system() == \u0026#39;windows\u0026#39; CFLAGS = [\u0026#39;-DWINDOWS\u0026#39;] else CFLAGS = [] endif CFLAGS += \u0026#39;-w\u0026#39; # generate qtdemo executable(\u0026#39;qtdemo\u0026#39;, sources: MHF_SRC, include_directories: INCLUDE_HDR, c_args : \u0026#39;\u0026#39;, cpp_args : CFLAGS, link_args: \u0026#39;\u0026#39;, dependencies: [qt5_dep] ) 静态编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 project(\u0026#39;qtdemo\u0026#39;, \u0026#39;cpp\u0026#39;, version : \u0026#39;0.1\u0026#39;, default_options : [\u0026#39;warning_level=3\u0026#39;, \u0026#39;buildtype=release\u0026#39;, \u0026#39;cpp_std=c++17\u0026#39;]) cxx = meson.get_compiler(\u0026#39;cpp\u0026#39;) qt5_mod = import(\u0026#39;qt5\u0026#39;) qt5_dep = dependency(\u0026#39;qt5\u0026#39;, modules: [\u0026#39;Core\u0026#39;, \u0026#39;Widgets\u0026#39;, \u0026#39;Gui\u0026#39;], static: true) qt5_path = \u0026#39;3rdparty/qt/\u0026#39; # qt library subdir(qt5_path) MHF_HDR = [] MHF_HDR += include_directories(\u0026#39;include\u0026#39;) MHF_HDR += QT_HDR MHF_SRC = [] MHF_SRC += \u0026#39;main.cpp\u0026#39; MHF_SRC += QT_SRC MHF_SRC += qt5_mod.compile_ui(sources : [qt5_path + \u0026#39;mainWindow.ui\u0026#39;]) MHF_SRC += qt5_mod.compile_moc(sources: [qt5_path + \u0026#39;source/mainWindow.cpp\u0026#39;], headers: [qt5_path + \u0026#39;include/mainWindow.h\u0026#39;]) LIBS = [] LIBS += qt5_dep LIBS += cxx.find_library(\u0026#39;Qt5Core\u0026#39;, dirs: meson.get_external_property(\u0026#39;qt_root\u0026#39;) + \u0026#39;lib/\u0026#39;, static: true) LIBS += cxx.find_library(\u0026#39;qtpcre2\u0026#39;, dirs: meson.get_external_property(\u0026#39;qt_root\u0026#39;) + \u0026#39;lib/\u0026#39;, static: true) LIBS += cxx.find_library(\u0026#39;QT5Widgets\u0026#39;, dirs: meson.get_external_property(\u0026#39;qt_root\u0026#39;) + \u0026#39;lib/\u0026#39;, static: true) LIBS += cxx.find_library(\u0026#39;Qt5Gui\u0026#39;, dirs: meson.get_external_property(\u0026#39;qt_root\u0026#39;) + \u0026#39;lib/\u0026#39;, static: true) LIBS += cxx.find_library(\u0026#39;qtlibpng\u0026#39;, dirs: meson.get_external_property(\u0026#39;qt_root\u0026#39;) + \u0026#39;lib/\u0026#39;, static: true) LIBS += cxx.find_library(\u0026#39;qtharfbuzz\u0026#39;, dirs: meson.get_external_property(\u0026#39;qt_root\u0026#39;) + \u0026#39;lib/\u0026#39;, static: true) # plugins LIBS += cxx.find_library(\u0026#39;qwindows\u0026#39;, dirs: meson.get_external_property(\u0026#39;qt_root\u0026#39;) + \u0026#39;plugins/platforms\u0026#39;, static: true) LIBS += cxx.find_library(\u0026#39;Qt5FontDatabaseSupport\u0026#39;, dirs: meson.get_external_property(\u0026#39;qt_root\u0026#39;) + \u0026#39;lib/\u0026#39;, static: true) LIBS += cxx.find_library(\u0026#39;qtfreetype\u0026#39;, dirs: meson.get_external_property(\u0026#39;qt_root\u0026#39;) + \u0026#39;lib/\u0026#39;, static: true) LIBS += cxx.find_library(\u0026#39;Qt5WindowsUIAutomationSupport\u0026#39;, dirs: meson.get_external_property(\u0026#39;qt_root\u0026#39;) + \u0026#39;lib/\u0026#39;, static: true) LIBS += cxx.find_library(\u0026#39;Qt5EventDispatcherSupport\u0026#39;, dirs: meson.get_external_property(\u0026#39;qt_root\u0026#39;) + \u0026#39;lib/\u0026#39;, static: true) LIBS += cxx.find_library(\u0026#39;Qt5ThemeSupport\u0026#39;, dirs: meson.get_external_property(\u0026#39;qt_root\u0026#39;) + \u0026#39;lib/\u0026#39;, static: true) if build_machine.system() == \u0026#39;windows\u0026#39; CXXFLAGS = [\u0026#39;-DWINDOWS\u0026#39;] else CXXFLAGS = [] endif CXXFLAGS += \u0026#39;-w\u0026#39; CXXFLAGS += \u0026#39;-static\u0026#39; LD_FLAGS = [] LD_FLAGS += \u0026#39;-lz\u0026#39; LD_FLAGS += \u0026#39;-lwsock32\u0026#39; LD_FLAGS += \u0026#39;-lopengl32\u0026#39; # GetFileVersionInfoSizeW LD_FLAGS += \u0026#39;-lversion\u0026#39; # __imp_GetUserProfileDirectoryW LD_FLAGS += \u0026#39;-luserenv\u0026#39; # NetShareEnum LD_FLAGS += \u0026#39;-lnetapi32\u0026#39; # __imp_timeSetEvent LD_FLAGS += \u0026#39;-lwinmm\u0026#39; # DwmGetWindowAttribute LD_FLAGS += \u0026#39;-ldwmapi\u0026#39; # ImmGetOpenStatus LD_FLAGS += \u0026#39;-limm32\u0026#39; # WTSFreeMemory LD_FLAGS += \u0026#39;-lwtsapi32\u0026#39; # generate qtdemo executable(\u0026#39;qtdemo\u0026#39;, sources: MHF_SRC, include_directories: MHF_HDR, c_args : \u0026#39;\u0026#39;, cpp_args : CXXFLAGS, link_args : LD_FLAGS, dependencies: LIBS, gui_app : true ) 一些笔记 去掉 meson 最后指定的gui_app : true可以在控制台看到 QT 程序不能启动的错误信息\n参考链接 https://mesonbuild.com/Qt5-module.html https://github.com/mesonbuild/meson/pull/7733 https://github.com/mesonbuild/meson/issues/2660 https://github.com/mxe/mxe/issues/1642 ","date":"2022-09-16T08:55:40Z","permalink":"https://binlep.github.io/p/qt--meson-%E7%BC%96%E8%AF%91%E6%96%B9%E5%BC%8F/","title":"QT + meson 编译方式"},{"content":"这是一篇 GCC 编译的疑难杂症文章\n常见问题 gcc 无法找到常用头文件 当我们利用如下命令查看 gcc 所使用的头文件目录时\n1 `gcc -print-prog-name=cc1` -v 发现目录为编译该 gcc 的人所使用的目录，而我们又没有该目录\n这种情况就需要自己去用-I来指定头文件目录了（视问题而定，不一定能解决）\nmusl-gcc 问题 弱类型问题 当我们看见如下错误\n1 2 alias.c: error: ‘nvram_commit_adv’ aliased to undefined symbol ‘nvram_commit’ 233 | int nvram_commit_adv(int) __attribute__((alias(\u0026#34;nvram_commit\u0026#34;))); 可以在alias.c中加一行同名空函数来解决问题\n1 static int nvram_commit() {} gethostbyname 函数崩溃 问题来源： 用 musl-gcc 静态编译带有gethostbyname函数的程序产生了段错误\nPs：musl 存在特殊的静态堆内存区\n在 Glibc 中，堆从一开始就动态申请和释放，而在 musl 中，程序开始的时候会把程序和 libc 空闲的区域当做堆内存（静态内存），优先从这里面划分空间，这部分空间用完之后再通过 mmap 进行分配\n问题原因： 静态链接下使用到了这种静态堆内存区，返回的是 64 位的地址，然后下一句汇编cdqe会按照 eax 的最高位，拓展出 rax 高 32 位的所有位，使其变为一个无效地址\n汇编演示如下：\n*RAX 0x7ffff7ff8050 —▸ 0x7ffff7ff809c ◂— \u0026#39;127.0.0.1\u0026#39; 0x4091f3 \u0026lt;main+86\u0026gt; call gethostbyname@plt \u0026lt;gethostbyname@plt\u0026gt; ► 0x4091f8 \u0026lt;main+91\u0026gt; cdqe 之后地址会变为\n*RAX 0xfffffffff7ff8050 导致最终我们得到了一个错误的struct hostent *类型的地址\n解决方法：\n发现编译的时候加了参数-std=c99，删掉这个参数就好了\n","date":"2022-09-15T21:39:10Z","permalink":"https://binlep.github.io/p/gcc-%E7%BC%96%E8%AF%91%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/","title":"GCC 编译从入门到入坟"},{"content":"固件仿真平台 以下是个人对于固件仿真这边推荐的几种实现方式\n自己写一个仿真平台（费时费力，但最好的是自己能够 DIY）\nemux（学会 DIY 后还蛮方便）\n项目地址：GitHub - therealsaumil/emux FAP（好处是还在更新）\n项目地址：GitHub - liyansong2018/firmware-analysis-plus FirmAE（本人用着有些 bug，用于挂载镜像的脚本处有问题）\n项目地址：GitHub - pr0v3rbs/FirmAE ","date":"2022-09-13T17:14:36Z","permalink":"https://binlep.github.io/p/%E5%9B%BA%E4%BB%B6%E4%BB%BF%E7%9C%9F%E7%9B%B8%E5%85%B3/","title":"固件仿真相关"}]